# E444-F2022-Lab6
This repo's code came from the following of the tutorial shown in https://github.com/mjhea0/flaskr-tdd

# Activity 2
The link [here](https://github.com/ECE444-2022Fall/project-1-web-application-design-education-pathways-group-17-mergers/blob/859bbce1a6394bcda5af20b159a08198dbceafd4/Education_Pathways/tests/test_app.py#L51-L120) leads to unit test written by me for Lab 6's submission. They include tests for searches by course code, minor name, and nonsense searches.

# Activity 3
The advantages of TDD center on the modularity offered through the purposeful testing of microfeatures and features throughout the develpopment process. TDD requires developers to write unit tests for features added throughout the development process to ensure they function as expected. This also leads to a focus on good architecture design through the necessitating of code to be unit testable. The resulting decoupling of code also further helps developers make changes to code with confidence, as the tests will help ensure if changes made pass required metrics while also ensuring code is modular enough that system-wide failure becomes highly unlikely with modularized code changes. The tests that emerge for TDD also help document code, as the requirements for success for each feature are clearly seen and tested for with the various test created throughout the process. In summary, the advantages of TDD center around the easier maintainability, higher modularity, forced formalized architectural design, code functionality assurance, and more confident collaboration that arise from its practices.

The disadvantages of TDD center on the additional work required to create and maintain good unit tests and tests that fit in the architecture laid out by both the project and TDD. The further modularization of the code to fit with TDD inspired tests itself also takes time. With legacy code that has no TDD implemented, the addition of TDD to the workflow is also very tedious, as not only are test required, but the architecture itself must be adjusted to allow for the modular unit tests that arise. Moreover, as the project and subsequently modules evolve over time, so must the tests to ensure they are still sensical and provide meaningful indicators of proper code functionality. The team as a whole must also fully commit to TDD, actively maintaining and creating tests, else TDD falls apart as the modular nature of the tests coupled with non-commitment with the team leads to whole suites of the codebase being improperly tested and maintained.
